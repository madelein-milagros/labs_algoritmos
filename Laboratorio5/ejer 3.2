class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class LinkedQueue:
    def __init__(self):
        self.front = None
        self.rear = None
        self._size = 0

    def is_empty(self):
        return self.front is None

    def enqueue(self, item):
        new_node = Node(item)
        if self.is_empty():
            self.front = new_node
        else:
            self.rear.next = new_node
        self.rear = new_node
        self._size += 1

    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        removed_value = self.front.value
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        self._size -= 1
        return removed_value

    def size(self):
        return self._size


# Algoritmo BFS
def breadth_first_search(graph, start_node):
    queue = LinkedQueue()
    visited = set()

    queue.enqueue(start_node)
    visited.add(start_node)

    result = []

    print(f"Starting BFS from node {start_node}")

    while not queue.is_empty():
        current = queue.dequeue()
        result.append(current)
        print(f"Visiting node: {current}")

        for neighbor in graph[current]:
            if neighbor not in visited:
                print(f"  Discovered neighbor: {neighbor}")
                queue.enqueue(neighbor)
                visited.add(neighbor)

    return result


# FunciÃ³n principal para probar BFS
def demonstrate_bfs():
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    print("Graph structure:")
    for node, neighbors in graph.items():
        print(f"  {node} -> {', '.join(neighbors)}")

    traversal = breadth_first_search(graph, 'A')

    print("\nBFS traversal order:")
    print(" -> ".join(traversal))


# Ejecutar todo
demonstrate_bfs()

