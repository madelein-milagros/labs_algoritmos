import time
import random

class Customer:
    def __init__(self, id, arrival_time, service_needs):
        self.id = id
        self.arrival_time = arrival_time
        self.service_needs = service_needs

    def __str__(self):
        return f"Customer {self.id} (arrived: {self.arrival_time:.1f}, needs: {self.service_needs:.1f}m)"

class ServiceCounter:
    def __init__(self, id, service_rate=2.0):
        self.id = id
        self.service_rate = service_rate
        self.current_customer = None
        self.time_remaining = 0

    def start_serving(self, customer, current_time):
        self.current_customer = customer
        self.time_remaining = customer.service_needs / self.service_rate
        print(f"Counter {self.id} started serving {customer} at time {current_time:.1f}")
        return self.time_remaining

    def update(self, time_delta):
        if self.current_customer:
            self.time_remaining -= time_delta
            if self.time_remaining <= 0:
                completed_customer = self.current_customer
                self.current_customer = None
                self.time_remaining = 0
                return completed_customer
        return None

    def is_available(self):
        return self.current_customer is None

class LinkedQueue:
    class Node:
        def __init__(self, item):
            self.item = item
            self.next = None

    def __init__(self):
        self.front = None
        self.rear = None
        self._size = 0

    def enqueue(self, item):
        new_node = self.Node(item)
        if self.rear:
            self.rear.next = new_node
        else:
            self.front = new_node
        self.rear = new_node
        self._size += 1

    def dequeue(self):
        if self.is_empty():
            return None
        item = self.front.item
        self.front = self.front.next
        if not self.front:
            self.rear = None
        self._size -= 1
        return item

    def is_empty(self):
        return self._size == 0

    def get_size(self):  # ← Cambiado de 'size()' a 'get_size()'
        return self._size

class CustomerServiceSystem:
    def __init__(self, num_counters=3):
        self.customer_queue = LinkedQueue()
        self.counters = [ServiceCounter(i, random.uniform(1.5, 2.5)) for i in range(1, num_counters + 1)]
        self.current_time = 0
        self.served_customers = 0
        self.total_wait_time = 0

    def add_customer(self, customer):
        self.customer_queue.enqueue(customer)
        print(f"Customer {customer.id} joined the queue at time {self.current_time:.1f}")

    def assign_customers(self):
        available_counters = [counter for counter in self.counters if counter.is_available()]
        while not self.customer_queue.is_empty() and available_counters:
            counter = available_counters.pop(0)
            customer = self.customer_queue.dequeue()
            wait_time = self.current_time - customer.arrival_time
            self.total_wait_time += wait_time
            self.served_customers += 1
            counter.start_serving(customer, self.current_time)

    def update(self, time_delta):
        self.current_time += time_delta
        for counter in self.counters:
            completed = counter.update(time_delta)
            if completed:
                print(f"Counter {counter.id} completed serving {completed} at time {self.current_time:.1f}")
        self.assign_customers()

    def get_status(self):
        active_counters = sum(1 for counter in self.counters if not counter.is_available())
        avg_wait = self.total_wait_time / self.served_customers if self.served_customers > 0 else 0
        return (f"Time: {self.current_time:.1f}, "
                f"Queue length: {self.customer_queue.get_size()}, "  # ← Aquí también se actualizó
                f"Active counters: {active_counters}/{len(self.counters)}, "
                f"Served customers: {self.served_customers}, "
                f"Average wait time: {avg_wait:.1f} minutes")

def run_customer_service_simulation():
    print("\nRunning Customer Service System Simulation:")
    system = CustomerServiceSystem(num_counters=3)
    arrival_rate = 0.2
    max_customers = 15
    for minute in range(60):
        if random.random() < arrival_rate and system.served_customers + system.customer_queue.get_size() < max_customers:
            customer_id = system.served_customers + system.customer_queue.get_size() + 1
            arrival_time = system.current_time
            service_needs = random.uniform(1.0, 5.0)
            new_customer = Customer(customer_id, arrival_time, service_needs)
            system.add_customer(new_customer)

        system.update(1.0)

        if minute % 10 == 0 or minute == 59:
            print(system.get_status())
    print("Simulation completed!")
if __name__ == "__main__":
    run_customer_service_simulation()
